#pragma once

#include "messages_detail.h"

/**
 * @file {{ msg.name }}.h
 * @brief {{ msg.name }} message type
 *
 * Auto-generated from messages.yaml - Do not edit manually!
 */

namespace ftl {
namespace messages {

// =============================================================================
// {{ msg.name }}
// =============================================================================

class {{ msg.name }}_View;
class {{ msg.name }}_Builder;

/**
 * @brief {{ msg.name }} message container
 * 
 * Provides nested type access: {{ msg.name }}::View and {{ msg.name }}::Builder
 */
class {{ msg.name }} {
public:
    using View = {{ msg.name }}_View;
    using Builder = {{ msg.name }}_Builder;
    static constexpr MessageType TYPE = MessageType::{{ msg.name }};
};

/**
 * @brief Read-only view of {{ msg.name }} message
 * 
 * Zero-copy accessor for received messages.
 * Lifetime is tied to underlying MessageHandle.
 */
class {{ msg.name }}_View {
private:
    const uint8_t* data_;
    uint8_t length_;
    
    friend MessageResult<{{ msg.name }}_View> parse_{{ msg.name }}(const ftl::MessageHandle&);
    
    {{ msg.name }}_View(const uint8_t* data, uint8_t length)
        : data_(data), length_(length) {}

public:
    static constexpr MessageType TYPE = MessageType::{{ msg.name }};
    
    // Field accessors
{% for field in msg.fields %}
{% if field.is_string %}
    std::string_view {{ field.name }}() const {
        size_t offset = 1;  // Skip message type byte
{% for prev_field in msg.fields[:loop.index0] %}
{% if prev_field.is_string %}
        detail::read_string(data_, offset, length_);  // Skip previous string
{% elif prev_field.is_array %}
        offset += {{ prev_field.size_expr }};  // Skip array
{% else %}
        offset += {{ prev_field.size_expr }};
{% endif %}
{% endfor %}
        return detail::read_string(data_, offset, length_);
    }
{% elif field.is_array %}
    {{ field.cpp_type }} {{ field.name }}() const {
        size_t offset = 1;  // Skip message type byte
{% for prev_field in msg.fields[:loop.index0] %}
{% if prev_field.is_string %}
        detail::read_string(data_, offset, length_);  // Skip previous string
{% elif prev_field.is_array %}
        offset += {{ prev_field.size_expr }};  // Skip array
{% else %}
        offset += {{ prev_field.size_expr }};
{% endif %}
{% endfor %}
        return detail::read_array<{{ field.element_type }}, {{ field.array_size }}>(data_, offset, length_);
    }
{% else %}
    {{ field.cpp_type }} {{ field.name }}() const {
        size_t offset = 1;  // Skip message type byte
{% for prev_field in msg.fields[:loop.index0] %}
{% if prev_field.is_string %}
        detail::read_string(data_, offset, length_);  // Skip previous string
{% elif prev_field.is_array %}
        offset += {{ prev_field.size_expr }};  // Skip array
{% else %}
        offset += {{ prev_field.size_expr }};
{% endif %}
{% endfor %}
        return detail::read_primitive<{{ field.type }}>(data_, offset);
    }
{% endif %}
{% endfor %}
    
    // Get message type
    MessageType type() const { return TYPE; }
};

/**
 * @brief Builder for {{ msg.name }} message
 * 
 * Fluent API for constructing messages.
 * Automatically manages MessageHandle lifecycle.
 */
class {{ msg.name }}_Builder {
private:
    ftl::MessagePoolType::Handle handle_;
    uint8_t* data_;
    size_t offset_;
    bool valid_;
    
    ftl::MessagePoolType& get_pool() {
        return get_message_pool();
    }

public:
    {{ msg.name }}_Builder() 
        : handle_(get_pool().acquire())
        , data_(nullptr)
        , offset_(3)  // Start after [LENGTH][SOURCE][TYPE]
        , valid_(handle_ != ftl::MessagePoolType::INVALID)
    {
        if (valid_) {
            data_ = get_pool().get_ptr<uint8_t>(handle_);
            if (data_) {
                // Buffer layout: [LENGTH][SOURCE][TYPE][FIELDS...]
                // Length and Source will be filled in build()
                data_[2] = static_cast<uint8_t>(MessageType::{{ msg.name }});
            } else {
                valid_ = false;
            }
        }
    }
    
    ~{{ msg.name }}_Builder() {
        if (handle_ != ftl::MessagePoolType::INVALID && valid_) {
            get_pool().release(handle_);
        }
    }
    
    // Disable copy, enable move
    {{ msg.name }}_Builder(const {{ msg.name }}_Builder&) = delete;
    {{ msg.name }}_Builder& operator=(const {{ msg.name }}_Builder&) = delete;
    
    {{ msg.name }}_Builder({{ msg.name }}_Builder&& other) noexcept
        : handle_(other.handle_)
        , data_(other.data_)
        , offset_(other.offset_)
        , valid_(other.valid_)
    {
        other.handle_ = ftl::MessagePoolType::INVALID;
        other.valid_ = false;
    }
    
{% for field in msg.fields %}
{% if field.is_string %}
    {{ msg.name }}_Builder& {{ field.name }}(std::string_view value) {
        if (valid_ && data_) {
            if (!detail::write_string(data_, offset_, ftl_config::MAX_PAYLOAD_SIZE, value)) {
                valid_ = false;
            }
        }
        return *this;
    }
{% elif field.is_array %}
    // Accept std::span<const {{ field.element_type }}>
    {{ msg.name }}_Builder& {{ field.name }}({{ field.builder_param_type }} values) {
        if (valid_ && data_) {
            if (!detail::write_array<{{ field.element_type }}, {{ field.array_size }}>(data_, offset_, ftl_config::MAX_PAYLOAD_SIZE, values)) {
                valid_ = false;
            }
        }
        return *this;
    }
    
    // Accept std::array<{{ field.element_type }}, {{ field.array_size }}>
    {{ msg.name }}_Builder& {{ field.name }}(const std::array<{{ field.element_type }}, {{ field.array_size }}>& values) {
        return {{ field.name }}(std::span<const {{ field.element_type }}>(values.data(), {{ field.array_size }}));
    }
{% else %}
    {{ msg.name }}_Builder& {{ field.name }}({{ field.cpp_type }} value) {
        if (valid_ && data_) {
            if (offset_ + sizeof({{ field.type }}) <= ftl_config::MAX_PAYLOAD_SIZE) {
                detail::write_primitive(data_, offset_, value);
            } else {
                valid_ = false;
            }
        }
        return *this;
    }
{% endif %}
{% endfor %}
    
    /**
     * @brief Build and return MessageHandle
     * 
     * Finalizes message construction and transfers ownership.
     * Builder becomes invalid after this call.
     * 
     * @return MessageHandle with constructed message, or invalid handle if build failed
     */
    ftl::MessageHandle build() {
        if (!valid_ || handle_ == ftl::MessagePoolType::INVALID) {
            return ftl::MessageHandle{};
        }
        
        // Calculate payload length: offset - 2 (skip LENGTH and SOURCE bytes)
        uint8_t payload_length = static_cast<uint8_t>(offset_ - 2);
        
        // Set buffer header: [LENGTH][SOURCE][TYPE][FIELDS...]
        data_[0] = payload_length;                      // Payload length
        data_[1] = ftl::get_my_source_id();        // Source ID
        // data_[2] already set to message type in constructor
        
        // Create MessageHandle with the raw handle
        auto msg_handle = ftl::MessageHandle(
            MsgHandle<ftl::MessagePoolType>(get_pool(), handle_)
        );
        
        // Transfer ownership
        handle_ = ftl::MessagePoolType::INVALID;
        valid_ = false;
        
        return msg_handle;
    }
    
    bool is_valid() const { return valid_; }
};

/**
 * @brief Parse {{ msg.name }} from MessageHandle
 */
inline MessageResult<{{ msg.name }}_View> parse_{{ msg.name }}(const ftl::MessageHandle& handle) {
    if (!handle.is_valid()) {
{% if use_expected %}
        return std::unexpected(MessageError::INVALID_HANDLE);
{% else %}
        return std::nullopt;
{% endif %}
    }
    
    const uint8_t* data = handle.data();
    uint8_t length = handle.length();
    
    if (length < 1) {
{% if use_expected %}
        return std::unexpected(MessageError::BUFFER_TOO_SMALL);
{% else %}
        return std::nullopt;
{% endif %}
    }
    
    MessageType type = static_cast<MessageType>(data[0]);
    if (type != MessageType::{{ msg.name }}) {
{% if use_expected %}
        return std::unexpected(MessageError::WRONG_MESSAGE_TYPE);
{% else %}
        return std::nullopt;
{% endif %}
    }
    
    return {{ msg.name }}_View(data, length);
}

} // namespace messages
} // namespace ftl
