#pragma once

/**
 * @file messages.h
 * @brief Main header for FTL protocol messages
 *
 * Auto-generated from messages.yaml - Do not edit manually!
 *
 * This file includes all message type definitions.
 * Individual message headers are in the messages/ directory.
 */

// Include common types and helpers
#include "messages_detail.h"

// Include all message type definitions
{% for msg in messages %}
#include "messages/{{ msg.name }}.h"
{% endfor %}

namespace ftl {
namespace messages {

// =============================================================================
// Message Dispatcher
// =============================================================================

/**
 * @brief Automatic message dispatcher with customizable handlers
 * 
 * Provides default print handlers for all message types.
 * Users can override with custom handlers using set_handler().
 * 
 * Example:
 *   Dispatcher dispatcher;
 *   
 *   // Override sensor data handler
 *   dispatcher.set_handler([](const MSG_SENSOR_DATA_View& msg) {
 *       // Custom handling
 *   });
 *   
 *   // Dispatch received messages
 *   while (ftl::has_msg()) {
 *       auto msg = ftl::get_msg();
 *       dispatcher.dispatch(msg);
 *   }
 *   
 *   // Send messages with type-safe interface
 *   dispatcher.send<MSG_LOG_STRING>("SYSTEM", "Hello World");
 *   dispatcher.send<MSG_SENSOR_DATA>(sensor_id, temp, pressure, humidity);
 */
class Dispatcher {
private:
{% for msg in messages %}
    std::function<void(const {{ msg.name }}_View&)> {{ msg.name | lower }}_handler_;
{% endfor %}

public:
    /**
     * @brief Constructor - initializes with default print handlers
     */
    Dispatcher();
    
    /**
     * @brief Dispatch a received message to appropriate handler
     *
     * @param handle MessageHandle containing the received message
     */
    void dispatch(ftl::MessageHandle& handle);
    
    // Handler setters (one for each message type)
{% for msg in messages %}
    void set_handler(std::function<void(const {{ msg.name }}_View&)> handler) {
        {{ msg.name | lower }}_handler_ = std::move(handler);
    }
{% endfor %}

    // =============================================================================
    // Type-safe Message Sending
    // =============================================================================
    
    /**
     * @brief Send a typed message with compile-time dispatch
     * 
     * Uses if constexpr for zero-overhead, compile-time message type selection.
     * Ensures correct argument types and count for each message.
     * 
     * Example:
     *   dispatcher.send<MSG_LOG_STRING>("SYSTEM", "Hello");
     *   dispatcher.send<MSG_SENSOR_DATA>(1, 25.5f, 101.3f, 60.0f);
     * 
     * @tparam MsgType Message type class (e.g., MSG_LOG_STRING)
     * @param args Message field values in declaration order
     * @return true if message was sent successfully
     */
    template<typename MsgType>
    bool send(auto&&... args) {
{% for msg in messages %}
        {% if loop.first %}if{% else %}else if{% endif %} constexpr (std::is_same_v<MsgType, {{ msg.name }}>) {
            return send_{{ msg.name | lower }}(std::forward<decltype(args)>(args)...);
        }
{% endfor %}
        else {
            static_assert(sizeof(MsgType) == 0, "Unknown message type");
            return false;
        }
    }

private:
    // Internal send implementations (one per message type)
{% for msg in messages %}
    bool send_{{ msg.name | lower }}({% for field in msg.fields %}{{ field.cpp_type }} {{ field.name }}{{ ", " if not loop.last }}{% endfor %});
{% endfor %}
};

// =============================================================================
// Default Print Handlers
// =============================================================================

{% for msg in messages %}
/**
 * @brief Default print handler for {{ msg.name }}
 */
void default_{{ msg.name }}_handler(const {{ msg.name }}_View& msg);

{% endfor %}

} // namespace messages
} // namespace ftl

namespace ftl {

/**
 * @brief Extended MessageHandle with typed message access
 */
class TypedMessageHandle : public MessageHandle {
public:
    using MessageHandle::MessageHandle;
    
    /**
     * @brief Cast message to specific type
     * 
     * @tparam T Message view type (e.g., MSG_SENSOR_DATA_View)
     * @return MessageResult<T> with typed view or error
     */
    template<typename T>
    messages::MessageResult<T> as() const {
        if (!is_valid()) {
{% if use_expected %}
            return std::unexpected(messages::MessageError::INVALID_HANDLE);
{% else %}
            return std::nullopt;
{% endif %}
        }
        
        const uint8_t* data = this->data();
        uint8_t length = this->length();
        
        if (length < 1) {
{% if use_expected %}
            return std::unexpected(messages::MessageError::BUFFER_TOO_SMALL);
{% else %}
            return std::nullopt;
{% endif %}
        }
        
        messages::MessageType type = static_cast<messages::MessageType>(data[0]);
        if (type != T::TYPE) {
{% if use_expected %}
            return std::unexpected(messages::MessageError::WRONG_MESSAGE_TYPE);
{% else %}
            return std::nullopt;
{% endif %}
        }
        
        // Use the parse function
        return messages::MessageResult<T>(T(data, length));
    }
};

} // namespace ftl
