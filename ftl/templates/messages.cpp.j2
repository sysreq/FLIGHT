#include "messages.h"

/**
 * @file messages.cpp
 * @brief Implementation of message helper functions
 *
 * Auto-generated from messages.yaml - Do not edit manually!
 */

namespace ftl {
namespace messages {

// =============================================================================
// Helper Function Implementations
// =============================================================================

const char* message_type_name(MessageType type) {
    switch (type) {
{% for msg in messages %}
    case MessageType::{{ msg.name }}: return "{{ msg.name }}";
{% endfor %}
    case MessageType::INVALID: return "INVALID";
    default: return "UNKNOWN";
    }
}

const char* error_name(MessageError error) {
    switch (error) {
    case MessageError::INVALID_HANDLE: return "INVALID_HANDLE";
    case MessageError::WRONG_MESSAGE_TYPE: return "WRONG_MESSAGE_TYPE";
    case MessageError::BUFFER_TOO_SMALL: return "BUFFER_TOO_SMALL";
    case MessageError::INVALID_STRING_LENGTH: return "INVALID_STRING_LENGTH";
    case MessageError::INVALID_ARRAY_SIZE: return "INVALID_ARRAY_SIZE";
    case MessageError::PARSE_ERROR: return "PARSE_ERROR";
    default: return "UNKNOWN_ERROR";
    }
}

// Global message pool accessor
// This must be defined in your main application or ftl core implementation
ftl::MessagePoolType& get_message_pool() {
    extern ftl::MessagePoolType g_message_pool;
    return g_message_pool;
}

// =============================================================================
// Generic Print Helper
// =============================================================================

namespace detail {
template<typename T>
void print_field(const char* name, T value) {
    printf("%s=", name);
    if constexpr (std::is_same_v<T, bool>) {
        printf("%s", value ? "true" : "false");
    } else if constexpr (std::is_floating_point_v<T>) {
        printf("%.2f", value);
    } else if constexpr (std::is_integral_v<T>) {
        if constexpr (std::is_signed_v<T>) {
            printf("%lld", static_cast<long long>(value));
        } else {
            printf("%llu", static_cast<unsigned long long>(value));
        }
    } else {
        printf("?");
    }
}

template<typename T>
void print_field(const char* name, std::span<const T> value) {
    printf("%s=[", name);
    for (size_t i = 0; i < value.size(); ++i) {
        print_field("", value[i]);
        if (i < value.size() - 1) printf(", ");
    }
    printf("]");
}

void print_field(const char* name, std::string_view value) {
    printf("%s='%.*s'", name, static_cast<int>(value.size()), value.data());
}
} // namespace detail

void print_message(const ftl::MessageHandle& handle) {
    if (!handle.is_valid()) {
        printf("Invalid message\n");
        return;
    }

    MessageType type = static_cast<MessageType>(handle.data()[0]);
    printf("%s: ", message_type_name(type));

    switch (type) {
{% for msg in messages %}
    case MessageType::{{ msg.name }}: {
        auto view_res = parse_{{ msg.name }}(handle);
        if (view_res) {
            auto& view = *view_res;
        {% for field in msg.fields %}
            detail::print_field("{{ field.name }}", view.{{ field.name }}());
            {% if not loop.last %}printf(", ");{% endif %}
        {% endfor %}
        }
        break;
    }
{% endfor %}
    default:
        printf("Unknown message");
    }
    printf("\n");
}


// =============================================================================
// Dispatcher Implementation
// =============================================================================

Dispatcher::Dispatcher() {
    // Initialize all handlers with a generic print handler
{% for msg in messages %}
    {{ msg.name | lower }}_handler_ = [](const {{ msg.name}}_View& msg) {
        // This is a bit of a hack to get the handle back
        // A better solution would be to pass the handle to the handler
        auto& pool = get_message_pool();
        auto* handle_ptr = reinterpret_cast<const ftl::MessageHandle*>(
            reinterpret_cast<const uint8_t*>(&msg) - offsetof(ftl::MessageHandle, data_));
        print_message(*handle_ptr);
    };
{% endfor %}
}

void Dispatcher::dispatch(ftl::MessageHandle& handle) {
    // Check message validity
    const uint8_t* data = handle.data();
    if (!data || handle.length() < 1) {
        printf("Invalid message: empty payload\n");
        return;
    }
    
    // Extract message type
    MessageType type = static_cast<MessageType>(data[0]);
    
    // Dispatch to appropriate handler
    switch (type) {
{% for msg in messages %}
    case MessageType::{{ msg.name }}: {
        auto result = parse_{{ msg.name }}(handle);
        if (result) {
            if ({{ msg.name | lower }}_handler_) {
                {{ msg.name | lower }}_handler_(*result);
            }
        } else {
{% if use_expected %}
            printf("Failed to parse {{ msg.name }}: %s\n", error_name(result.error()));
{% else %}
            printf("Failed to parse {{ msg.name }}\n");
{% endif %}
        }
        break;
    }
{% endfor %}
    
    default:
        printf("Unknown message type: %u\n", static_cast<uint8_t>(type));
        break;
    }
}

// =============================================================================
// Dispatcher send() Implementations
// =============================================================================

{% for msg in messages %}
bool Dispatcher::send_{{ msg.name | lower }}({% for field in msg.fields %}{{ field.builder_param_type }} {{ field.name }}{{ ", " if not loop.last }}{% endfor %}) {
    auto msg = {{ msg.name }}::Builder()
{% for field in msg.fields %}
        .{{ field.name }}({{ field.name }})
{% endfor %}
        .build();
    
    if (msg.is_valid()) {
        return ftl::send_msg(msg.span());
    }
    return false;
}

{% endfor %}

} // namespace messages
} // namespace ftl
